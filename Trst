#!/bin/bash


echo "--- Démarrage de la vérification des variables d'environnement ---"
echo "Fichier de référence : $VAR_FILE"
echo "Scripts à analyser : $SCRIPTS_DIR"
echo "------------------------------------------------------------------"

# 1. Récupération des noms de variables exportées (plus robuste)
# On filtre les lignes 'export VAR=value', on prend le premier mot après 'export',
# et on ne garde que le nom (en coupant au '=' ou en prenant le nom).
# La commande 'sed' est souvent plus simple ici. On cherche le mot après 'export'
# et on le coupe au premier caractère non-alphanumérique ou au '='.
# Ici, on utilise 'grep' avec une expression régulière Perl-compatible pour une meilleure précision.
# On filtre uniquement les noms de variables (lettres, chiffres, underscore, majuscules recommandées pour l'environnement).
VARS=$(grep -oP 'export\s+([A-Z_][A-Z0-9_]*)' "$VAR_FILE" | awk '{print $2}' | sed 's/=.*//' | sort -u)

echo "Total de variables exportées trouvées : $(echo "$VARS" | wc -l)"
echo ""
echo "## Variables qui ne semblent plus être utilisées :"
echo "-------------------------------------------------"

# 2. Boucle de vérification
for var in $VARS; do
    # -R : récursif
    # -q : mode silencieux (ne renvoie rien en sortie, juste le code de retour)
    # --exclude : exclut le fichier d'origine de la recherche
    # -e : permet de spécifier plusieurs motifs de recherche (recherche $var ET ${var})
    # L'utilisation de \$$var et \${$var} assure que l'on recherche l'usage de la variable,
    # et non juste une chaîne de caractères qui contiendrait le nom de la variable.
    
    # On vérifie si la variable est utilisée.
    if grep -R -q -e "\$$var" -e "\${$var}" --exclude="$VAR_FILE" "$SCRIPTS_DIR" 2>/dev/null; then
        # Variable utilisée, on ne fait rien ou on affiche en mode debug si besoin.
        : # continue
    else
        # Variable NON utilisée, on l'affiche
        echo "$var"
    fi
done

echo "-------------------------------------------------"
echo "Vérification terminée."
